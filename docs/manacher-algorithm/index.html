<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Manacher's Algorithm | Sổ tay của Henry</title><meta name=keywords content="math,algorithm"><meta name=description content="Mình mới gặp và tìm hiểu thuật toán này 🐳, khi đang làm 1 bài trên leetcode 😃
Thế nào là 1 Palindrome ? Mình hiểu palindrome là 1 chuỗi ký tự đối xứng. Ví dụ:
Chuỗi &ldquo;cabadabac&rdquo; là 1 palindrome. Vì chuỗi này đối xứng qua ký tự &rsquo;d&rsquo; ở vị trí 4 (tính từ 0, theo cách index trong javascript). Hay chuỗi &ldquo;acbaabca&rdquo; cũng là 1 palindrome, chuỗi này đối xứng qua vị trí giữa 2 ký tự &lsquo;a&rsquo;."><meta name=author content="Ngo Van Trung"><link rel=canonical href=https://TrungNgoVan.github.io/blog/docs/manacher-algorithm/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.f4609a383e3709a645f04e13d4129372693d13a8636500ddef16d617cfef25a4.css integrity="sha256-9GCaOD43CaZF8E4T1BKTcmk9E6hjZQDd7xbWF8/vJaQ=" rel="preload stylesheet" as=style><link rel=icon href=https://TrungNgoVan.github.io/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://TrungNgoVan.github.io/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://TrungNgoVan.github.io/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://TrungNgoVan.github.io/blog/apple-touch-icon.png><link rel=mask-icon href=https://TrungNgoVan.github.io/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css integrity=sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js integrity=sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:title" content="Manacher's Algorithm"><meta property="og:description" content="Mình mới gặp và tìm hiểu thuật toán này 🐳, khi đang làm 1 bài trên leetcode 😃
Thế nào là 1 Palindrome ? Mình hiểu palindrome là 1 chuỗi ký tự đối xứng. Ví dụ:
Chuỗi &ldquo;cabadabac&rdquo; là 1 palindrome. Vì chuỗi này đối xứng qua ký tự &rsquo;d&rsquo; ở vị trí 4 (tính từ 0, theo cách index trong javascript). Hay chuỗi &ldquo;acbaabca&rdquo; cũng là 1 palindrome, chuỗi này đối xứng qua vị trí giữa 2 ký tự &lsquo;a&rsquo;."><meta property="og:type" content="article"><meta property="og:url" content="https://TrungNgoVan.github.io/blog/docs/manacher-algorithm/"><meta property="og:image" content="https://TrungNgoVan.github.io/blog/images/example.jpg"><meta property="article:section" content="docs"><meta property="article:published_time" content="2023-06-12T17:27:53+07:00"><meta property="article:modified_time" content="2023-06-12T17:27:53+07:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://TrungNgoVan.github.io/blog/images/example.jpg"><meta name=twitter:title content="Manacher's Algorithm"><meta name=twitter:description content="Mình mới gặp và tìm hiểu thuật toán này 🐳, khi đang làm 1 bài trên leetcode 😃
Thế nào là 1 Palindrome ? Mình hiểu palindrome là 1 chuỗi ký tự đối xứng. Ví dụ:
Chuỗi &ldquo;cabadabac&rdquo; là 1 palindrome. Vì chuỗi này đối xứng qua ký tự &rsquo;d&rsquo; ở vị trí 4 (tính từ 0, theo cách index trong javascript). Hay chuỗi &ldquo;acbaabca&rdquo; cũng là 1 palindrome, chuỗi này đối xứng qua vị trí giữa 2 ký tự &lsquo;a&rsquo;."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Docs","item":"https://TrungNgoVan.github.io/blog/docs/"},{"@type":"ListItem","position":2,"name":"Manacher's Algorithm","item":"https://TrungNgoVan.github.io/blog/docs/manacher-algorithm/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Manacher's Algorithm","name":"Manacher\u0027s Algorithm","description":"Mình mới gặp và tìm hiểu thuật toán này 🐳, khi đang làm 1 bài trên leetcode 😃\nThế nào là 1 Palindrome ? Mình hiểu palindrome là 1 chuỗi ký tự đối xứng. Ví dụ:\nChuỗi \u0026ldquo;cabadabac\u0026rdquo; là 1 palindrome. Vì chuỗi này đối xứng qua ký tự \u0026rsquo;d\u0026rsquo; ở vị trí 4 (tính từ 0, theo cách index trong javascript). Hay chuỗi \u0026ldquo;acbaabca\u0026rdquo; cũng là 1 palindrome, chuỗi này đối xứng qua vị trí giữa 2 ký tự \u0026lsquo;a\u0026rsquo;.","keywords":["math","algorithm"],"articleBody":"Mình mới gặp và tìm hiểu thuật toán này 🐳, khi đang làm 1 bài trên leetcode 😃\nThế nào là 1 Palindrome ? Mình hiểu palindrome là 1 chuỗi ký tự đối xứng. Ví dụ:\nChuỗi “cabadabac” là 1 palindrome. Vì chuỗi này đối xứng qua ký tự ’d’ ở vị trí 4 (tính từ 0, theo cách index trong javascript). Hay chuỗi “acbaabca” cũng là 1 palindrome, chuỗi này đối xứng qua vị trí giữa 2 ký tự ‘a’.\nĐể dễ hình dung hơn, các bạn có thể tưởng tưởng 1 palindrome được tạo ra bằng cách phản chiếu 1 chuỗi ký tự qua “gương”.\nVậy sub-palindromes (còn gọi là palindrome substrings) là các chuỗi con của một chuỗi ban đầu và là palindrome.\nTheo mình tìm hiểu thì sub-palindromes là một khái niệm quan trọng trong xử lý chuỗi và có ứng dụng trong nhiều bài toán, bao gồm tìm kiếm từ, mã hóa, nén dữ liệu và xử lý ngôn ngữ tự nhiên. Trong bài viết này mình sẽ nói đến 1 bài toán khá hay. Go go 🐳\nBài toán: Tìm tất cả các sub-palindromes trong thời gian $O(n)$ Bài toán Cho chuỗi $s$ với độ dài $n$ . Tìm tất cả các cặp $(i, j)$ sao cho chuỗi con $s[i\\dots j]$ là một chuỗi đối xứng. Chuỗi $t$ là một chuỗi đối xứng khi $t = t_{rev}$ ( $t_{rev}$ là một chuỗi đảo ngược của $t$ ).\nPhân tích Chuỗi đối xứng ở đây chính là palindrome mình đã đề cập ở trên.\nTrong trường hợp xấu nhất, chuỗi ban đầu có thể có tới $O(n^2)$ chuỗi con đối xứng. Lúc đầu mình nhìn qua thì nghĩ là không có thuật toán tuyến tính nào cho bài toán này. Tức là sẽ không có bài viết này 👀\nPhân tích kỹ hơn 🔎: Các palindrome sẽ có độ dài lẻ và chẵn khác nhau, và được tính riêng là $d_{odd}[i]$ và $d_{even}[i]$ . Đối với các palindrome có độ dài chẵn, chúng ta giả định rằng chúng có tâm ở vị trí $i$ nếu hai ký tự trung tâm của chúng là $s[i]$ và $s[i-1]$ .\nVí dụ, chuỗi $s = abababc$ có 3 palindromes có độ dài lẻ với tâm ở vị trí $s[3] = b$ , tức là $d_{odd}[3] = 3$ :\na b a b ⏟ s 3 a b ⏞ d o d d [ 3 ] = 3 c Và chuỗi $s = cbaabd$ có 2 palindromes có độ dài bằng nhau với tâm ở vị trí $s[3] = a$ , tức là $d_{even}[3] = 2$ :\nc b a a ⏟ s 3 b ⏞ d e v e n [ 3 ] = 2 d Thực tế, vấn đề này đã có nhiều giải pháp: với String Hashing, nó có thể được giải quyết trong $O(n\\cdot \\log n)$ , và với Suffix Trees và Fast LCA , vấn đề này có thể được giải quyết trong $O(n)$ . Các bạn có thể tự tìm hiểu.\nNhưng thuật toán mình nói trong đến trong bài này đơn giản hơn và có ít hằng số ẩn hơn về độ phức tạp của bộ nhớ và thời gian. Thuật toán này được phát hiện bởi Glenn K. Manacher vào năm 1975.\nVề ý tưởng cốt lõi là tính toán số lượng palindrome hiện tại dựa trên thông tin palindrome được tính toán trước đó. Nghe giống DP nhỉ 👀\nCode thôi 💻 Động não 🤔 Để xử lý vấn đề palindrome có độ dài lẻ và chẵn khác nhau, thay vì tính toán cho cả 2 trường hợp. Chúng ta sẽ biến đổi chuỗi ban đầu 1 chút. Cụ thể, mình sẽ thêm ký tự # vào đầu, cuối và giữa các ký tự của chuỗi ban đầu. Trông nó sẽ như vậy:\nSau khi modify chuỗi, chúng ta sẽ luôn thu được 1 chuỗi mới có độ dài lẻ. Và sẽ không có trường hợp palindrome có độ dài chẵn tạo bởi các ký tự trong chuỗi ban đầu.\nBởi vì giữa chúng luôn có ký tự ’#’. Do đó chúng ta đã bỏ qua được vấn đề phải tính toán số lượng các palindromes có độ dài chẵn.\nVậy giờ mình chỉ cần tìm số lượng các palindrome lẻ và lưu lại. 👀 Nghe dễ nhỉ\nThuật toán “ngây thơ” Khởi tạo một biến đếm tên res để theo dõi số lượng xâu đối xứng. Tạo một chuỗi bắt đầu bằng ‘^’ và kết thúc bằng ‘$’ là newS được tạo bằng cách chèn ký tự # giữa mỗi ký tự của chuỗi đầu vào s. Tạo mảng p[] đại diện cho $d_{odd}[]$ Lặp lại từng chỉ số $i$ của chuỗi được sửa đổi newS. Đối với mỗi chỉ số $i$, khởi tạo các biến l và r bằng 1, và p[i] bằng 0. Thực hiện vòng lặp while khi các ký tự tại các chỉ số $i - l$ và $i + r$ hợp lệ và bằng nhau. Vòng lặp này mở rộng xâu đối xứng được tập trung tại chỉ số i và đếm số lượng xâu đối xứng. Bên trong vòng lặp, tăng p[i] lên 1 và cập nhật l và r bằng cách tăng chúng lên 1. Sau khi vòng lặp while kết thúc, thêm Math.ceil(p[i] / 2) vào res. Điều này là vì mỗi chuỗi đối xứng hợp lệ được tính hai lần (một lần cho độ dài lẻ và một lần cho độ dài chẵn), vì vậy chúng ta chia p[i] cho 2 và lấy giá trị làm tròn của nó. Lặp lại các bước 4-7 cho tất cả các chỉ số $i$ của chuỗi được sửa đổi newS. Cuối cùng, trả về giá trị của res, đại diện cho tổng số lượng xâu đối xứng trong chuỗi ban đầu s. Mình dùng Javascript để code bài này:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var SubPalindromes = function (s) { let res = 0; let newS = \"^#\"; for (let i = 0; i \u003c s.length; i++) { newS += s[i] + \"#\"; } newS += \"$\"; let n = newS.length, l, r, count; let p = new Array(n).fill(0); for (let i = 1; i \u003c n - 1; i++) { p[i] = 0; l = 1; r = 1; while (i - l \u003e= 0 \u0026\u0026 i + r \u003c n \u0026\u0026 newS[i - l] == newS[i + r]) { p[i]++; l++; r++; } res += Math.ceil(p[i] / 2); } return res; }; Độ phức tạp Thời gian: $O(n^2)$, trong đó n là độ dài của chuỗi đầu vào s. Thuật toán lặp qua từng ký tự của chuỗi đã sửa đổi được xử lý và đối với mỗi ký tự, nó mở rộng bảng màu ở cả hai bên. Trong trường hợp xấu nhất, mỗi ký tự của newS có thể là trung tâm của một palindrome, dẫn đến các lần lặp O(n^2). Không gian: $O(n)$, trong đó n là độ dài của chuỗi đầu vào s. Chuỗi đã sửa đổi processS yêu cầu thêm dung lượng O(n) để lưu trữ phiên bản đã sửa đổi. Thuật toán Manacher’s 🐳 Với thuật tóa này, mình sẽ duy trì cặp biên $(l, r)$ của palindrome dài nhất hiện tại (tức sub-palindromes của s dài nhất bắt đầu từ $s[l+1]$ và kết thúc tại $s[r-1]$). Ban đầu, ta thiết lập $l = 0, r = 1$ , tương ứng với chuỗi rỗng. (Để gọn thì mình sẽ gọi “palindrome dài nhất hiện tại” là maxPalindrome)\nBây giờ, chúng ta cần tính toán $d_{odd}[i]$, trong đó tất cả các giá trị trước đó trong $d_{odd}[]$ đã được tính toán. Thuật toán trông như sau:\nNếu $i$ không thuộc maxPalindrome, tức là $i \\geq r$, chúng ta sẽ thực hiện tương tự thuật toán “Ngây thơ” ở trên.\nCụ thể, chúng ta sẽ tăng lần lượt $d_{odd}[i]$ và mỗi lần sẽ kiểm tra xem chuỗi con $[i - d_{odd}[i]\\dots i + d_{odd}[i]]$ có phải là một palindrome hay không. Nếu không hoặc vượt quá chuỗi $s$, chúng ta sẽ dừng lại. Sau khi kết thúc, mình tính đươc $d_{odd}[i]$ và lưu lại. Cuối cùng, mình sẽ cập nhật maxPalindrome $(l, r)$. Bước này khá đơn giản, nên tự làm nhé 👀\nBây giờ, xét trường hợp khi $i \\lt r$. Mình sẽ tìm vị trí “đối xứng” của $i$ trong maxPalindrome $(l, r)$, tức là sẽ lấy vị trí $j = l + (r - i)$ và lấy giá trị của $d_{odd}[j]$. Vì $j$ là vị trí đối xứng với $i$ qua tâm $(l+r)/2$, mình có thể gán $d_{odd}[i] = d_{odd}[j]$. Giải thích cho điều này (palindrome tâm $j$ thực sự được “sao chép” vào palindrome tâm $i$):\n… s l + 1 … s j − d o d d [ j ] + 1 … s j … s j + d o d d [ j ] − 1 ⏟ palindrome tâm j … s i − d o d d [ j ] + 1 … s i … s i + d o d d [ j ] − 1 ⏟ palindrome tâm i … s r − 1 ⏞ maxPalindrome … Cách này đã giảm đi khá nhiều độ phức tạp, thay vì mình phải tính $d_{odd}[i]$, mình sẽ dùng lại $d_{odd}[j]$ đã tính trước đó thông qua tính chất đối xứng, đơn giản ha 🐧\nNhưng có một trường hợp đặc biệt: khi palindrome đang xét thuộc maxPalindrome nhưng vượt quá biên của nó, tức là $j - d_{odd}[j] \\le l$ (hoặc $i + d_{odd}[j] \\ge r$ ). Mình sẽ không chắc chắn được lúc này $d_{odd}[i]$ có bằng $d_{odd}[j]$ hay không ? Vì đã vượt ra ngoài maxPalindrome, mà chúng ta chỉ kiếm soát được sự đối xứng bên trong maxPalindrome thôi 🐧.\nĐể xử lý thì lúc đó mình sẽ đặt $d_{odd}[i] = r - i$. Sau đó, sẽ chạy thuật toán “Ngây thơ” để cố gắng tăng $d_{odd}[i]$. Cách này vẫn sẽ giúp chúng ta giảm bớt được 1 khoảng nào đó khi tính toán $d_{odd}[i]$ so với việc “Ngây thơ” từ đầu. 👀\nCuối cùng vẫn không quên cập nhật maxPalindrome $(l, r)$\nSau khi kết thúc quá trình tính toán, việc còn lại đơn giản là trả về tổng của $d_{odd}[]$ để có được tổng sub-palindromes.\nMình code bằng Javascript, vì trong bài này, vai trò của $l$ và $r$ giống nhau (vì tính đối xứng) và mình không dùng tới $l$ nên không đưa vào cho đơn giản 🐳\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 let SubPalindromes = function (s) { let n = s.length; let newS = \"^#\"; for (let i = 0; i \u003c n; i++) { newS += s[i] + \"#\"; } newS += \"$\"; let p = new Array(newS.length).fill(0); let center = 0, r = 0; for (let i = 1; i \u003c newS.length - 1; i++) { let mirror = 2 * center - i; if (i \u003c r) { p[i] = Math.min(r - i, p[mirror]); } while (newS[i + p[i] + 1] == newS[i - p[i] - 1]) { p[i]++; } if (i + p[i] \u003e r) { center = i; r = i + p[i]; } } let result = p.reduce((a, b) =\u003e a + Math.floor((b + 1) / 2)); return result; }; Độ phức tạp Thoạt nhìn, không rõ ràng là thuật toán này có độ phức tạp thời gian tuyến tính, bởi vì mình đã chạy thuật toán “Ngây thơ” trong khi chạy thuật toán Manacher’.\nTuy nhiên, các bạn có thể thấy rằng mỗi lần lặp lại thuật toán “Ngây thơ” đều tăng $r$ ít nhất là 1 đơn vị. Và $r$ không thể giảm trong thuật toán. Vì vậy, thuật toán “Ngây thơ” sẽ tăng $r$ n lần hay tổng số lần lặp là $O(n)$ .\nCác phần khác của thuật toán Manacher’s hoạt động rõ ràng trong thời gian tuyến tính. Như vậy, mình nhận được độ phức tạp về thời gian là $O(n)$.\n","wordCount":"2082","inLanguage":"en","image":"https://TrungNgoVan.github.io/blog/images/example.jpg","datePublished":"2023-06-12T17:27:53+07:00","dateModified":"2023-06-12T17:27:53+07:00","author":{"@type":"Person","name":"Ngo Van Trung"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://TrungNgoVan.github.io/blog/docs/manacher-algorithm/"},"publisher":{"@type":"Organization","name":"Sổ tay của Henry","logo":{"@type":"ImageObject","url":"https://TrungNgoVan.github.io/blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://TrungNgoVan.github.io/blog/ accesskey=h title="🐳 Sổ tay của Henry (Alt + H)">🐳 Sổ tay của Henry</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://TrungNgoVan.github.io/blog/about/ title=About><span>About</span></a></li><li><a href=https://TrungNgoVan.github.io/blog/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://TrungNgoVan.github.io/blog/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://TrungNgoVan.github.io/blog/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://TrungNgoVan.github.io/blog/cv.pdf title=CV><span>CV</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://TrungNgoVan.github.io/blog/>Home</a>&nbsp;»&nbsp;<a href=https://TrungNgoVan.github.io/blog/docs/>Docs</a></div><h1 class=post-title>Manacher's Algorithm</h1><div class=post-meta><span title='2023-06-12 17:27:53 +0700 +0700'>June 12, 2023</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Ngo Van Trung&nbsp;|&nbsp;<a href=https://github.com/TrungNgoVan/blog/blob/main/content/docs/Manacher-algorithm.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=https://TrungNgoVan.github.io/blog/images/example.jpg alt=Cover><p>Cover</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#th%e1%ba%bf-n%c3%a0o-l%c3%a0-1-palindrome- aria-label="Thế nào là 1 Palindrome ?">Thế nào là 1 Palindrome ?</a></li><li><a href=#b%c3%a0i-to%c3%a1n-t%c3%acm-t%e1%ba%a5t-c%e1%ba%a3-c%c3%a1c-sub-palindromes-trong-th%e1%bb%9di-gian-on aria-label="Bài toán: Tìm tất cả các sub-palindromes trong thời gian $O(n)$">Bài toán: Tìm tất cả các sub-palindromes trong thời gian $O(n)$</a><ul><li><a href=#b%c3%a0i-to%c3%a1n aria-label="Bài toán">Bài toán</a></li><li><a href=#ph%c3%a2n-t%c3%adch aria-label="Phân tích">Phân tích</a></li></ul></li><li><a href=#code-th%c3%b4i- aria-label="Code thôi 💻">Code thôi 💻</a><ul><li><a href=#%c4%91%e1%bb%99ng-n%c3%a3o- aria-label="Động não 🤔">Động não 🤔</a></li><li><a href=#thu%e1%ba%adt-to%c3%a1n-ng%c3%a2y-th%c6%a1 aria-label="Thuật toán &amp;ldquo;ngây thơ&amp;rdquo;">Thuật toán &ldquo;ngây thơ&rdquo;</a><ul><li><a href=#%c4%91%e1%bb%99-ph%e1%bb%a9c-t%e1%ba%a1p aria-label="Độ phức tạp">Độ phức tạp</a></li></ul></li><li><a href=#thu%e1%ba%adt-to%c3%a1n-manachers- aria-label="Thuật toán Manacher&amp;rsquo;s 🐳">Thuật toán Manacher&rsquo;s 🐳</a><ul><li><a href=#%c4%91%e1%bb%99-ph%e1%bb%a9c-t%e1%ba%a1p-1 aria-label="Độ phức tạp">Độ phức tạp</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><p>Mình mới gặp và tìm hiểu thuật toán này 🐳, khi đang làm 1 bài trên <a href=https://leetcode.com/problems/palindromic-substrings/description/>leetcode</a> 😃</p><h1 id=thế-nào-là-1-palindrome->Thế nào là 1 Palindrome ?<a hidden class=anchor aria-hidden=true href=#thế-nào-là-1-palindrome->#</a></h1><p>Mình hiểu <code>palindrome</code> là 1 chuỗi ký tự đối xứng. Ví dụ:</p><p><img loading=lazy src=../../images/example.jpg alt=example></p><p>Chuỗi &ldquo;cabadabac&rdquo; là 1 <code>palindrome</code>. Vì chuỗi này đối xứng qua ký tự &rsquo;d&rsquo; ở vị trí 4 (tính từ 0, theo cách index trong javascript). Hay chuỗi &ldquo;acbaabca&rdquo; cũng là 1 <code>palindrome</code>, chuỗi này đối xứng qua vị trí giữa 2 ký tự &lsquo;a&rsquo;.</p><p>Để dễ hình dung hơn, các bạn có thể tưởng tưởng 1 <code>palindrome</code> được tạo ra bằng cách phản chiếu 1 chuỗi ký tự qua &ldquo;gương&rdquo;.</p><p>Vậy <code>sub-palindromes</code> (còn gọi là <code>palindrome substrings</code>) là các chuỗi con của một chuỗi ban đầu và là <code>palindrome</code>.</p><p>Theo mình tìm hiểu thì <code>sub-palindromes</code> là một khái niệm quan trọng trong xử lý chuỗi và có ứng dụng trong nhiều bài toán, bao gồm tìm kiếm từ, mã hóa, nén dữ liệu và xử lý ngôn ngữ tự nhiên. Trong bài viết này mình sẽ nói đến 1 bài toán khá hay. Go go 🐳</p><h1 id=bài-toán-tìm-tất-cả-các-sub-palindromes-trong-thời-gian-on>Bài toán: Tìm tất cả các sub-palindromes trong thời gian $O(n)$<a hidden class=anchor aria-hidden=true href=#bài-toán-tìm-tất-cả-các-sub-palindromes-trong-thời-gian-on>#</a></h1><h2 id=bài-toán>Bài toán<a hidden class=anchor aria-hidden=true href=#bài-toán>#</a></h2><blockquote><p>Cho chuỗi  $s$  với độ dài  $n$ . Tìm tất cả các cặp  $(i, j)$  sao cho chuỗi con  $s[i\dots j]$  là một chuỗi đối xứng. Chuỗi  $t$  là một chuỗi đối xứng khi  $t = t_{rev}$  ( $t_{rev}$  là một chuỗi đảo ngược của  $t$ ).</p></blockquote><h2 id=phân-tích>Phân tích<a hidden class=anchor aria-hidden=true href=#phân-tích>#</a></h2><ul><li><p>Chuỗi đối xứng ở đây chính là <code>palindrome</code> mình đã đề cập ở trên.</p></li><li><p>Trong trường hợp xấu nhất, chuỗi ban đầu có thể có tới  $O(n^2)$  chuỗi con đối xứng. Lúc đầu mình nhìn qua thì nghĩ là không có thuật toán tuyến tính nào cho bài toán này. Tức là sẽ không có bài viết này 👀</p></li><li><p>Phân tích kỹ hơn 🔎: Các palindrome sẽ có độ dài lẻ và chẵn khác nhau, và được tính riêng là  $d_{odd}[i]$  và  $d_{even}[i]$ . Đối với các palindrome có độ dài chẵn, chúng ta giả định rằng chúng có tâm ở vị trí  $i$  nếu hai ký tự trung tâm của chúng là  $s[i]$  và  $s[i-1]$ .</p><p>Ví dụ, chuỗi  $s = abababc$  có 3 palindromes có độ dài lẻ với tâm ở vị trí  $s[3] = b$ , tức là $d_{odd}[3] = 3$ :</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mi>a</mi>
  <mtext>&#xA0;</mtext>
  <mover>
    <mrow data-mjx-texclass="OP">
      <mover>
        <mrow>
          <mi>b</mi>
          <mtext>&#xA0;</mtext>
          <mi>a</mi>
          <mtext>&#xA0;</mtext>
          <munder>
            <mrow data-mjx-texclass="OP">
              <munder>
                <mi>b</mi>
                <mo>&#x23DF;</mo>
              </munder>
            </mrow>
            <mrow data-mjx-texclass="ORD">
              <msub>
                <mi>s</mi>
                <mn>3</mn>
              </msub>
            </mrow>
          </munder>
          <mtext>&#xA0;</mtext>
          <mi>a</mi>
          <mtext>&#xA0;</mtext>
          <mi>b</mi>
        </mrow>
        <mo>&#x23DE;</mo>
      </mover>
    </mrow>
    <mrow data-mjx-texclass="ORD">
      <msub>
        <mi>d</mi>
        <mrow data-mjx-texclass="ORD">
          <mi>o</mi>
          <mi>d</mi>
          <mi>d</mi>
        </mrow>
      </msub>
      <mo stretchy="false">[</mo>
      <mn>3</mn>
      <mo stretchy="false">]</mo>
      <mo>=</mo>
      <mn>3</mn>
    </mrow>
  </mover>
  <mi>c</mi>
</math><p>Và chuỗi  $s = cbaabd$  có 2 palindromes có độ dài bằng nhau với tâm ở vị trí  $s[3] = a$ , tức là $d_{even}[3] = 2$ :</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mi>c</mi>
  <mtext>&#xA0;</mtext>
  <mover>
    <mrow data-mjx-texclass="OP">
      <mover>
        <mrow>
          <mi>b</mi>
          <mtext>&#xA0;</mtext>
          <mi>a</mi>
          <mtext>&#xA0;</mtext>
          <munder>
            <mrow data-mjx-texclass="OP">
              <munder>
                <mi>a</mi>
                <mo>&#x23DF;</mo>
              </munder>
            </mrow>
            <mrow data-mjx-texclass="ORD">
              <msub>
                <mi>s</mi>
                <mn>3</mn>
              </msub>
            </mrow>
          </munder>
          <mtext>&#xA0;</mtext>
          <mi>b</mi>
        </mrow>
        <mo>&#x23DE;</mo>
      </mover>
    </mrow>
    <mrow data-mjx-texclass="ORD">
      <msub>
        <mi>d</mi>
        <mrow data-mjx-texclass="ORD">
          <mi>e</mi>
          <mi>v</mi>
          <mi>e</mi>
          <mi>n</mi>
        </mrow>
      </msub>
      <mo stretchy="false">[</mo>
      <mn>3</mn>
      <mo stretchy="false">]</mo>
      <mo>=</mo>
      <mn>2</mn>
    </mrow>
  </mover>
  <mi>d</mi>
</math></li></ul><p>Thực tế, vấn đề này đã có nhiều giải pháp: với String Hashing, nó có thể được giải quyết trong  $O(n\cdot \log n)$ , và với Suffix Trees và Fast LCA , vấn đề này có thể được giải quyết trong $O(n)$ . Các bạn có thể tự tìm hiểu.</p><p>Nhưng thuật toán mình nói trong đến trong bài này đơn giản hơn và có ít hằng số ẩn hơn về độ phức tạp của bộ nhớ và thời gian. Thuật toán này được phát hiện bởi <strong>Glenn K. Manacher</strong> vào năm 1975.</p><p>Về <strong>ý tưởng</strong> cốt lõi là tính toán số lượng palindrome hiện tại dựa trên thông tin palindrome được tính toán trước đó. Nghe giống DP nhỉ 👀</p><h1 id=code-thôi->Code thôi 💻<a hidden class=anchor aria-hidden=true href=#code-thôi->#</a></h1><h2 id=động-não->Động não 🤔<a hidden class=anchor aria-hidden=true href=#động-não->#</a></h2><p>Để xử lý vấn đề palindrome có độ dài lẻ và chẵn khác nhau, thay vì tính toán cho cả 2 trường hợp. Chúng ta sẽ biến đổi chuỗi ban đầu 1 chút. Cụ thể, mình sẽ thêm ký tự <code>#</code> vào đầu, cuối và giữa các ký tự của chuỗi ban đầu. Trông nó sẽ như vậy:</p><p><img loading=lazy src=../../images/modify.jpg alt=example></p><p>Sau khi modify chuỗi, chúng ta sẽ luôn thu được 1 chuỗi mới có độ dài lẻ. Và sẽ không có trường hợp palindrome có độ dài chẵn tạo bởi các ký tự trong chuỗi ban đầu.</p><p>Bởi vì giữa chúng luôn có ký tự <strong>&rsquo;#&rsquo;</strong>. Do đó chúng ta đã bỏ qua được vấn đề phải tính toán số lượng các palindromes có độ dài chẵn.</p><p>Vậy giờ mình chỉ cần tìm số lượng các palindrome lẻ và lưu lại. 👀 Nghe dễ nhỉ</p><h2 id=thuật-toán-ngây-thơ>Thuật toán &ldquo;ngây thơ&rdquo;<a hidden class=anchor aria-hidden=true href=#thuật-toán-ngây-thơ>#</a></h2><ol><li>Khởi tạo một biến đếm tên <code>res</code> để theo dõi số lượng xâu đối xứng.</li><li>Tạo một chuỗi bắt đầu bằng &lsquo;^&rsquo; và kết thúc bằng &lsquo;$&rsquo; là <code>newS</code> được tạo bằng cách chèn ký tự <code>#</code> giữa mỗi ký tự của chuỗi đầu vào s.</li><li>Tạo mảng <code>p[]</code> đại diện cho $d_{odd}[]$</li><li>Lặp lại từng chỉ số $i$ của chuỗi được sửa đổi <code>newS</code>.</li><li>Đối với mỗi chỉ số $i$, khởi tạo các biến <code>l</code> và <code>r</code> bằng 1, và <code>p[i]</code> bằng 0.</li><li>Thực hiện vòng lặp while khi các ký tự tại các chỉ số $i - l$ và $i + r$ hợp lệ và bằng nhau. Vòng lặp này mở rộng xâu đối xứng được tập trung tại chỉ số i và đếm số lượng xâu đối xứng.</li><li>Bên trong vòng lặp, tăng <code>p[i]</code> lên 1 và cập nhật <code>l</code> và <code>r</code> bằng cách tăng chúng lên 1.</li><li>Sau khi vòng lặp while kết thúc, thêm <code>Math.ceil(p[i] / 2)</code> vào <code>res</code>. Điều này là vì mỗi chuỗi đối xứng hợp lệ được tính hai lần (một lần cho độ dài lẻ và một lần cho độ dài chẵn), vì vậy chúng ta chia <code>p[i]</code> cho 2 và lấy giá trị làm tròn của nó.</li><li>Lặp lại các bước 4-7 cho tất cả các chỉ số $i$ của chuỗi được sửa đổi <code>newS</code>.</li><li>Cuối cùng, trả về giá trị của <code>res</code>, đại diện cho tổng số lượng xâu đối xứng trong chuỗi ban đầu s.</li></ol><p>Mình dùng <strong>Javascript</strong> để code bài này:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>var</span> <span class=nx>SubPalindromes</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>res</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>newS</span> <span class=o>=</span> <span class=s2>&#34;^#&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>s</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>newS</span> <span class=o>+=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>+</span> <span class=s2>&#34;#&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>newS</span> <span class=o>+=</span> <span class=s2>&#34;$&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>n</span> <span class=o>=</span> <span class=nx>newS</span><span class=p>.</span><span class=nx>length</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>l</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>r</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>p</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Array</span><span class=p>(</span><span class=nx>n</span><span class=p>).</span><span class=nx>fill</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>p</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>l</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nx>r</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=nx>i</span> <span class=o>-</span> <span class=nx>l</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>i</span> <span class=o>+</span> <span class=nx>r</span> <span class=o>&lt;</span> <span class=nx>n</span> <span class=o>&amp;&amp;</span> <span class=nx>newS</span><span class=p>[</span><span class=nx>i</span> <span class=o>-</span> <span class=nx>l</span><span class=p>]</span> <span class=o>==</span> <span class=nx>newS</span><span class=p>[</span><span class=nx>i</span> <span class=o>+</span> <span class=nx>r</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>p</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=nx>l</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=nx>r</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=o>+=</span> <span class=nb>Math</span><span class=p>.</span><span class=nx>ceil</span><span class=p>(</span><span class=nx>p</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>/</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=độ-phức-tạp>Độ phức tạp<a hidden class=anchor aria-hidden=true href=#độ-phức-tạp>#</a></h3><ul><li><strong>Thời gian</strong>: $O(n^2)$, trong đó n là độ dài của chuỗi đầu vào s. Thuật toán lặp qua từng ký tự của chuỗi đã sửa đổi được xử lý và đối với mỗi ký tự, nó mở rộng bảng màu ở cả hai bên. Trong trường hợp xấu nhất, mỗi ký tự của <code>newS</code> có thể là trung tâm của một palindrome, dẫn đến các lần lặp O(n^2).</li><li><strong>Không gian</strong>: $O(n)$, trong đó n là độ dài của chuỗi đầu vào s. Chuỗi đã sửa đổi processS yêu cầu thêm dung lượng O(n) để lưu trữ phiên bản đã sửa đổi.</li></ul><h2 id=thuật-toán-manachers->Thuật toán Manacher&rsquo;s 🐳<a hidden class=anchor aria-hidden=true href=#thuật-toán-manachers->#</a></h2><p>Với thuật tóa này, mình sẽ duy trì cặp biên $(l, r)$ của palindrome dài nhất hiện tại (tức sub-palindromes của s dài nhất bắt đầu từ $s[l+1]$ và kết thúc tại $s[r-1]$). Ban đầu, ta thiết lập $l = 0, r = 1$ , tương ứng với chuỗi rỗng. (Để gọn thì mình sẽ gọi &ldquo;palindrome dài nhất hiện tại&rdquo; là <strong>maxPalindrome</strong>)</p><p>Bây giờ, chúng ta cần tính toán $d_{odd}[i]$, trong đó tất cả các giá trị trước đó trong $d_{odd}[]$ đã được tính toán. Thuật toán trông như sau:</p><ul><li><p>Nếu $i$ không thuộc maxPalindrome, tức là $i \geq r$, chúng ta sẽ thực hiện tương tự <a href=#thu%E1%BA%ADt-to%C3%A1n-ng%C3%A2y-th%C6%A1>thuật toán &ldquo;Ngây thơ&rdquo;</a> ở trên.</p><p>Cụ thể, chúng ta sẽ tăng lần lượt $d_{odd}[i]$ và mỗi lần sẽ kiểm tra xem chuỗi con $[i - d_{odd}[i]\dots i + d_{odd}[i]]$ có phải là một palindrome hay không. Nếu không hoặc vượt quá chuỗi $s$, chúng ta sẽ dừng lại. Sau khi kết thúc, mình tính đươc $d_{odd}[i]$ và lưu lại. Cuối cùng, mình sẽ cập nhật maxPalindrome $(l, r)$. Bước này khá đơn giản, nên tự làm nhé 👀</p></li><li><p>Bây giờ, xét trường hợp khi $i \lt r$. Mình sẽ tìm vị trí &ldquo;đối xứng&rdquo; của $i$ trong maxPalindrome $(l, r)$, tức là sẽ lấy vị trí $j = l + (r - i)$ và lấy giá trị của $d_{odd}[j]$. Vì $j$ là vị trí đối xứng với $i$ qua tâm $(l+r)/2$, mình có thể gán $d_{odd}[i] = d_{odd}[j]$. Giải thích cho điều này (palindrome tâm $j$ thực sự được &ldquo;sao chép&rdquo; vào palindrome tâm $i$):</p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mo>&#x2026;</mo>
  <mtext>&#xA0;</mtext>
  <mover>
    <mrow data-mjx-texclass="OP">
      <mover>
        <mrow>
          <msub>
            <mi>s</mi>
            <mrow data-mjx-texclass="ORD">
              <mi>l</mi>
              <mo>+</mo>
              <mn>1</mn>
            </mrow>
          </msub>
          <mtext>&#xA0;</mtext>
          <mo>&#x2026;</mo>
          <mtext>&#xA0;</mtext>
          <munder>
            <mrow data-mjx-texclass="OP">
              <munder>
                <mrow>
                  <msub>
                    <mi>s</mi>
                    <mrow data-mjx-texclass="ORD">
                      <mi>j</mi>
                      <mo>&#x2212;</mo>
                      <msub>
                        <mi>d</mi>
                        <mrow data-mjx-texclass="ORD">
                          <mi>o</mi>
                          <mi>d</mi>
                          <mi>d</mi>
                        </mrow>
                      </msub>
                      <mo stretchy="false">[</mo>
                      <mi>j</mi>
                      <mo stretchy="false">]</mo>
                      <mo>+</mo>
                      <mn>1</mn>
                    </mrow>
                  </msub>
                  <mtext>&#xA0;</mtext>
                  <mo>&#x2026;</mo>
                  <mtext>&#xA0;</mtext>
                  <msub>
                    <mi>s</mi>
                    <mi>j</mi>
                  </msub>
                  <mtext>&#xA0;</mtext>
                  <mo>&#x2026;</mo>
                  <mtext>&#xA0;</mtext>
                  <msub>
                    <mi>s</mi>
                    <mrow data-mjx-texclass="ORD">
                      <mi>j</mi>
                      <mo>+</mo>
                      <msub>
                        <mi>d</mi>
                        <mrow data-mjx-texclass="ORD">
                          <mi>o</mi>
                          <mi>d</mi>
                          <mi>d</mi>
                        </mrow>
                      </msub>
                      <mo stretchy="false">[</mo>
                      <mi>j</mi>
                      <mo stretchy="false">]</mo>
                      <mo>&#x2212;</mo>
                      <mn>1</mn>
                    </mrow>
                  </msub>
                  <mtext>&#xA0;</mtext>
                </mrow>
                <mo>&#x23DF;</mo>
              </munder>
            </mrow>
            <mtext>palindrome tâm j</mtext>
          </munder>
          <mtext>&#xA0;</mtext>
          <mo>&#x2026;</mo>
          <mtext>&#xA0;</mtext>
          <munder>
            <mrow data-mjx-texclass="OP">
              <munder>
                <mrow>
                  <msub>
                    <mi>s</mi>
                    <mrow data-mjx-texclass="ORD">
                      <mi>i</mi>
                      <mo>&#x2212;</mo>
                      <msub>
                        <mi>d</mi>
                        <mrow data-mjx-texclass="ORD">
                          <mi>o</mi>
                          <mi>d</mi>
                          <mi>d</mi>
                        </mrow>
                      </msub>
                      <mo stretchy="false">[</mo>
                      <mi>j</mi>
                      <mo stretchy="false">]</mo>
                      <mo>+</mo>
                      <mn>1</mn>
                    </mrow>
                  </msub>
                  <mtext>&#xA0;</mtext>
                  <mo>&#x2026;</mo>
                  <mtext>&#xA0;</mtext>
                  <msub>
                    <mi>s</mi>
                    <mi>i</mi>
                  </msub>
                  <mtext>&#xA0;</mtext>
                  <mo>&#x2026;</mo>
                  <mtext>&#xA0;</mtext>
                  <msub>
                    <mi>s</mi>
                    <mrow data-mjx-texclass="ORD">
                      <mi>i</mi>
                      <mo>+</mo>
                      <msub>
                        <mi>d</mi>
                        <mrow data-mjx-texclass="ORD">
                          <mi>o</mi>
                          <mi>d</mi>
                          <mi>d</mi>
                        </mrow>
                      </msub>
                      <mo stretchy="false">[</mo>
                      <mi>j</mi>
                      <mo stretchy="false">]</mo>
                      <mo>&#x2212;</mo>
                      <mn>1</mn>
                    </mrow>
                  </msub>
                  <mtext>&#xA0;</mtext>
                </mrow>
                <mo>&#x23DF;</mo>
              </munder>
            </mrow>
            <mtext>palindrome tâm i</mtext>
          </munder>
          <mtext>&#xA0;</mtext>
          <mo>&#x2026;</mo>
          <mtext>&#xA0;</mtext>
          <msub>
            <mi>s</mi>
            <mrow data-mjx-texclass="ORD">
              <mi>r</mi>
              <mo>&#x2212;</mo>
              <mn>1</mn>
            </mrow>
          </msub>
          <mtext>&#xA0;</mtext>
        </mrow>
        <mo>&#x23DE;</mo>
      </mover>
    </mrow>
    <mtext>maxPalindrome</mtext>
  </mover>
  <mtext>&#xA0;</mtext>
  <mo>&#x2026;</mo>
</math><p>Cách này đã giảm đi khá nhiều độ phức tạp, thay vì mình phải tính $d_{odd}[i]$, mình sẽ dùng lại $d_{odd}[j]$ đã tính trước đó thông qua tính chất đối xứng, đơn giản ha 🐧</p><p>Nhưng có một trường hợp đặc biệt: khi palindrome đang xét thuộc maxPalindrome nhưng vượt quá biên của nó, tức là $j - d_{odd}[j] \le l$  (hoặc  $i + d_{odd}[j] \ge r$ ). Mình sẽ không chắc chắn được lúc này $d_{odd}[i]$ có bằng $d_{odd}[j]$ hay không ? Vì đã vượt ra ngoài maxPalindrome, mà chúng ta chỉ kiếm soát được sự đối xứng bên trong maxPalindrome thôi 🐧.</p><p>Để xử lý thì lúc đó mình sẽ đặt $d_{odd}[i] = r - i$. Sau đó, sẽ chạy thuật toán &ldquo;Ngây thơ&rdquo; để cố gắng tăng  $d_{odd}[i]$. Cách này vẫn sẽ giúp chúng ta giảm bớt được 1 khoảng nào đó khi tính toán  $d_{odd}[i]$ so với việc &ldquo;Ngây thơ&rdquo; từ đầu. 👀</p><p>Cuối cùng vẫn không quên cập nhật maxPalindrome $(l, r)$</p></li></ul><p>Sau khi kết thúc quá trình tính toán, việc còn lại đơn giản là trả về tổng của  $d_{odd}[]$ để có được tổng sub-palindromes.</p><p>Mình code bằng <strong>Javascript</strong>, vì trong bài này, vai trò của $l$ và $r$ giống nhau (vì tính đối xứng) và mình không dùng tới $l$ nên không đưa vào cho đơn giản 🐳</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>let</span> <span class=nx>SubPalindromes</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>(</span><span class=nx>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>n</span> <span class=o>=</span> <span class=nx>s</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>newS</span> <span class=o>=</span> <span class=s2>&#34;^#&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>newS</span> <span class=o>+=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>+</span> <span class=s2>&#34;#&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=nx>newS</span> <span class=o>+=</span> <span class=s2>&#34;$&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>p</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Array</span><span class=p>(</span><span class=nx>newS</span><span class=p>.</span><span class=nx>length</span><span class=p>).</span><span class=nx>fill</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>center</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nx>r</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>newS</span><span class=p>.</span><span class=nx>length</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nx>mirror</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=nx>center</span> <span class=o>-</span> <span class=nx>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>i</span> <span class=o>&lt;</span> <span class=nx>r</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>p</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>Math</span><span class=p>.</span><span class=nx>min</span><span class=p>(</span><span class=nx>r</span> <span class=o>-</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>p</span><span class=p>[</span><span class=nx>mirror</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=nx>newS</span><span class=p>[</span><span class=nx>i</span> <span class=o>+</span> <span class=nx>p</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=nx>newS</span><span class=p>[</span><span class=nx>i</span> <span class=o>-</span> <span class=nx>p</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>-</span> <span class=mi>1</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>p</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nx>i</span> <span class=o>+</span> <span class=nx>p</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=nx>r</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>center</span> <span class=o>=</span> <span class=nx>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=nx>r</span> <span class=o>=</span> <span class=nx>i</span> <span class=o>+</span> <span class=nx>p</span><span class=p>[</span><span class=nx>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>result</span> <span class=o>=</span> <span class=nx>p</span><span class=p>.</span><span class=nx>reduce</span><span class=p>((</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>a</span> <span class=o>+</span> <span class=nb>Math</span><span class=p>.</span><span class=nx>floor</span><span class=p>((</span><span class=nx>b</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=độ-phức-tạp-1>Độ phức tạp<a hidden class=anchor aria-hidden=true href=#độ-phức-tạp-1>#</a></h3><p>Thoạt nhìn, không rõ ràng là thuật toán này có độ phức tạp thời gian tuyến tính, bởi vì mình đã chạy <a href=#thu%E1%BA%ADt-to%C3%A1n-ng%C3%A2y-th%C6%A1>thuật toán &ldquo;Ngây thơ&rdquo;</a> trong khi chạy thuật toán Manacher&rsquo;.</p><p>Tuy nhiên, các bạn có thể thấy rằng mỗi lần lặp lại thuật toán &ldquo;Ngây thơ&rdquo; đều tăng $r$  ít nhất là 1 đơn vị. Và  $r$  không thể giảm trong thuật toán. Vì vậy, thuật toán &ldquo;Ngây thơ&rdquo; sẽ tăng $r$ n lần hay tổng số lần lặp là $O(n)$ .</p><p>Các phần khác của thuật toán Manacher&rsquo;s hoạt động rõ ràng trong thời gian tuyến tính. Như vậy, mình nhận được  độ phức tạp về thời gian là $O(n)$.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://TrungNgoVan.github.io/blog/tags/math/>math</a></li><li><a href=https://TrungNgoVan.github.io/blog/tags/algorithm/>algorithm</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Manacher's Algorithm on twitter" href="https://twitter.com/intent/tweet/?text=Manacher%27s%20Algorithm&url=https%3a%2f%2fTrungNgoVan.github.io%2fblog%2fdocs%2fmanacher-algorithm%2f&hashtags=math%2calgorithm"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Manacher's Algorithm on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fTrungNgoVan.github.io%2fblog%2fdocs%2fmanacher-algorithm%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://TrungNgoVan.github.io/blog/>Sổ tay của Henry</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>